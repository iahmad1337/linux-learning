# New
- This is based on bjnet guide: https://beej.us/guide/bgnet/html/split-wide/index.html

# Old contents
- based on a random book I found some time ago in library at my workplace

/etc/services
inetd - demon that needs to ve working if I want to test my programs offline
1) Создание сокета 2) Поиск адресата 3) организация канала связи 4) разрыв
соединения
[0-255].[0-255].[0-255].[0-255]:[0-65535] - IP:Port, иногда номер порта
добавляется через точку
telnet 127.0.0.1 21

Остановился на странице 34-35 и застрял на том что connection refused по любому
порту на локалхосте :(

Я понял почему не работает: на этом порте просто никто не слушает и не читает.
Вот как посмотреть список портов и кто за ними сидит:
https://www.linux.org.ru/forum/admin/6801613
`netstat -anp` можно ещё судо добавить

// 54.205.198.81:443

man read - возвращаемые значения. Можно читать из дескриптора сокета так же как
по файловому дескриптору.

man recv - более изощренная операция чтения, можно передавать флажки

man 2 shutdown - можно закрыть канал для чтения и/или записи

Сетевой драйвер преобразует IP в MAC c помощью ARP (Address Resolution Protocol
[RFC826]).

Формат IP-адреса: <Класс сети>.<Сеть>.<Подсеть>.<Узел>

Есть пять классов сетей плюс один класс (0.0.0.0-0.255.255.255) зарезервирован
(страница 44).

Сейчас маршрутизаторы работают по протоколу CIDR (Classless Internet Domain
Routing [RFC1517-1519]).

Маска подсети - всё до самой младшей единички. Все нолики перед ней могут
представлять адреса в подсети.
Нулевой адрес подсети зарезервирован. Адрес со всеми единичками является
широковещательным, им нельзя адресоать компьютеры.

Остановился на 45 странице.

Когда компьютер подключается к сети, посылает в подсеть широковещательное
сообщение и в нём указывает: идентификатор Ethernet, IP адрес

DHCP (Dynamic Host Configuration Protocol [RFC2131]) - благодаря этому ни один
компьютер не владеет постоянным адресом.

EINVAL - если две программы захотят слушать/писать на одном порте. Чтобы этого
избежать есть SO_REUSEADDR

Если у программы установлин бит SUID выполняется как как если бы её запустил
владелец (в т.ч. root)

Эфемерный порт, это когда мы явно не указываем порт и система назначает нам его
автоматически

Правило из книжки: не запускать свои сетевые приложухи с рута, использовать
безопасные номера портов (<1024) и вести журнал поступающих сообщений

Порядок байт: обратный (big endian) и прямой (small endian). В сетевых
протоколах всегда big endian.

man gethostbyname - порезолвить имя в один или больше айпишников

Остановился на 52 странице

int write(int fd, const void* buf, size_t count) - пишем в цикле, можно и с
файлами так делать
int send(int fd, const void* buf, size_t count, int flags) - write специфичный
для сокетов. Обычно нужна чтоб передать серверу служебную информацию

https://pubs.opengroup.org/onlinepubs/7908799/xsh/unistd.h.html

Если сервер не закроет соединение когда мы делаем recv в цикле - мы зависаем

Типы пакетов:
PF_LOCAL - именованный сокет
PF_INET - стек протоколов TCP/IP
PF_IPX - стек протоколов Novell
PF_APPLETALK - стек протоколов AppleTalk

Именованный сокет - это тупо штука в файлово системе, ничего из сети не сможет
добраться до него. На 56 странице сказано как с ним работать - просто поменять в
коде клиента AF_INET на AF_LOCAL и пишем в поле sun_path путь к файлу в котором
хотим сделать сокет.

Закончил главу 3, следующая на странице 59

Четыре вида пакетов в физической сети: неструктурированный, ICMP, UDP (без
подтверждения доставки), TCP (потоковая передача).
В IP-пакете есть три части: (отправитель, адресат, данные).
Вот его полная структура:
https://github.com/strongswan/strongswan/blob/master/src/libipsec/ip_packet.c

В поле protocol лежит что-то из IPROTO_(ICMP, UDP, TCP) - это всё в
`netinet/in.h`. Можно изменить вручную если указать параметр SOCK_RAW.
Этот параметр можно задать только под рутом.

TCP гарантирует порядок пакетов (не посылает сообщение, пока не послали
предыдущее).

tcpdump - только под рутом, опасно. Чекает все пакеты которые гоняются по сети
(а я так и не понял, это прямо произвольные пакеты которые могут быть
предназначены другим компьютерам?). Эта штука не видит пакеты от команды `ping
127.0.0.1`
Свой собственный tcpdump:
```
sd = socket(PF_INET, SOCK_PACKET, фильтр(?));
bytes_read = recvfrom(sd, buffer, sizeof(buffer), 0, 0, 0);
```
В качестве фильтра передаются какие-то шизо-флаги:
`ETH_P802_3` и т.д. Но зато есть один человеческий фильтр `ETH_ALL` (автор
говорит быть с ним осторожным).
Фулл прога называется `snooper.c`, можно посмотреть.
SOCK_PACKET - readonly сокет апаратного уровня.

Закончил третью главу, страница 78

Когда вызываем connect для UDP, то адресата просто уведомят о том что он будет
получать сообщения. Можно так же как и в случае TCP подключиться и делать send
Обычно с UDP используют `sendto` и `recvfrom`.
См. пример сервера в connected-peer.c
Можно многократно подключиться к разным серверам не закрывая сокет.

Есть протокол RDP (Reliable Data Protocol) [RFC908, RFC1151] - компромисс междуUDP & TCP.

Пример со скачиванием веб-странички с помощью протокола http: http-client.c

Инфа о версиях http есть на w3c.org

Остановился на страничке 86. Почему автор не оставил адрес своего сайта...

Gcc flags: -Wall -Wextra -std=c11 -pedantic
man 7 ip - info about how to get tcp/udp/raw socket.

```
typedef uint32_t in_addr_t;

struct in_addr {
    in_addr_t s_addr;
};

struct sockaddr {
    sa_family_t sa_family;
    char sa_data[14];
};

struct sockaddr_in {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;
};
```

